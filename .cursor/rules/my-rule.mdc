---
alwaysApply: false
---
# Cisco NSO + LlamaIndex AI Context Rules

You are an expert in Python, Cisco NSO (Network Services Orchestrator), and LlamaIndex AI automation.

## Key Principles
- Write concise, technical responses with accurate Python examples.
- Use functional, declarative programming; avoid classes where possible except for NSO service callbacks and LlamaIndex custom components.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., is_deployed, has_device, needs_sync).
- Use lowercase with underscores for directories and files (e.g., nso_services/l3vpn_mapping.py).
- Favor named exports for service mappings and utility functions.
- Use the Receive an Object, Return an Object (RORO) pattern where applicable.

## Python/NSO/LlamaIndex
- Use def for function definitions.
- Use type hints for all function signatures where possible.
- File structure: NSO packages, service mappings, LlamaIndex agents, utilities, config.
- Avoid unnecessary curly braces in conditional statements.
- For single-line statements in conditionals, omit curly braces.
- Use concise, one-line syntax for simple conditional statements (e.g., if condition: do_something()).
- Follow PEP 8 style guidelines for Python code.
- Use list comprehensions and generator expressions for concise data transformations.
- Leverage Python's standard library effectively (itertools, functools, collections).
- Use context managers (with statements) for resource management.

## Error Handling and Validation
- Prioritize error handling and edge cases:
  - Handle errors and edge cases at the beginning of functions.
  - Use early returns for error conditions to avoid deeply nested if statements.
  - Place the happy path last in the function for improved readability.
  - Avoid unnecessary else statements; use the if-return pattern instead.
  - Use guard clauses to handle preconditions and invalid states early.
  - Implement proper error logging with NSO's logging facilities.
  - Handle MAAPI/MAAGIC exceptions gracefully.
  - Validate device connectivity and transaction states early.
  - Use custom error types for NSO-specific errors (e.g., device unreachable, transaction conflicts).

## Dependencies
- **Cisco NSO**: ncs, _ncs, ncs.maapi, ncs.maagic
- **LlamaIndex**: llama-index, llama-index-core, llama-index-llms-*
- **MCP**: mcp, fastmcp
- **AI/ML**: openai, anthropic, langchain (optional)
- **Data Processing**: pydantic, marshmallow, pandas, numpy
- **Jupyter**: jupyter, ipykernel, ipywidgets, nbformat
- **Visualization**: matplotlib, seaborn, plotly
- **Utilities**: pyyaml, jinja2, requests, asyncio

## Cisco NSO-Specific Guidelines
- Use MAAPI (Management Agent API) for programmatic access to CDB and device configurations.
- Leverage MAAGIC (MAAPI Magic) for pythonic access to NSO data models.
- Implement service callbacks following NSO conventions (cb_create, cb_pre_modification, cb_post_modification).
- Use NSO's transaction management properly (read/write transactions, commit queues).
- Implement proper device template generation and mapping logic.
- Use NSO's XPath queries for efficient data retrieval.
- Leverage NSO's service FASTMAP for efficient configuration diffing.
- Handle device groups, device templates, and NED (Network Element Driver) specifics.
- Use NSO's progress trace for long-running operations.
- Implement proper rollback handling for failed service deployments.

## LlamaIndex-Specific Guidelines
- Use appropriate LLMs (OpenAI, Claude, local models) based on task requirements.
- Implement custom document loaders for NSO YANG models and network configurations.
- Create vector stores for efficient retrieval of network documentation and configurations.
- Use query engines for natural language interaction with network data.
- Implement agents for complex automation workflows (analysis, planning, execution).
- Use structured outputs (Pydantic models) for parsing LLM responses into NSO service inputs.
- Leverage LlamaIndex's callback system for monitoring and debugging.
- Implement retry logic and error handling for LLM API calls.
- Use streaming responses for better user experience in interactive scenarios.
- Integrate MCP tools as LlamaIndex function tools for extended capabilities.

## FastMCP and MCP Tools Development Guidelines
- Use FastMCP for rapid MCP server development with minimal boilerplate.
- Implement MCP tools as async functions with proper type hints.
- Use Pydantic models for tool input validation and schema generation.
- Decorate tools with @mcp.tool() for automatic registration.
- Implement resource providers using @mcp.resource() for exposing NSO data.
- Use @mcp.prompt() for reusable prompt templates.
- Structure MCP servers modularly: separate tools for device operations, service management, and queries.
- Implement proper error handling in MCP tools with descriptive error messages.
- Use async/await patterns for non-blocking NSO operations.
- Leverage MCP's context system for maintaining state across tool calls.
- Implement pagination for large datasets (device lists, configuration data).
- Use MCP's progress notifications for long-running operations.
- Create composite tools that orchestrate multiple NSO operations.
- Implement proper authentication and authorization in MCP servers.
- Use environment variables for NSO connection details and credentials.
- Log all MCP tool invocations for audit and debugging purposes.

## MCP + LlamaIndex Integration Patterns
- Register MCP tools as LlamaIndex FunctionTools for agent workflows.
- Use MCP resources as data sources for LlamaIndex vector stores.
- Implement MCP prompts as LlamaIndex prompt templates.
- Create hybrid workflows: LlamaIndex reasoning → MCP tool execution → NSO actions.
- Use MCP for real-time NSO operations and LlamaIndex for analysis and planning.
- Implement feedback loops: MCP executes → LlamaIndex validates → iterate if needed.
- Cache MCP tool results in LlamaIndex memory for context-aware conversations.
- Use MCP's streaming for real-time updates to LlamaIndex agents.

## Jupyter Notebook-Specific Guidelines
- Structure notebooks with clear markdown cells explaining each section.
- Use meaningful cell outputs and suppress unnecessary verbose output.
- Implement proper notebook organization: imports → configuration → functions → execution → visualization.
- Use magic commands effectively (%time, %timeit, %load_ext, %%writefile).
- Leverage ipywidgets for interactive controls and dashboards.
- Use display() and IPython.display for rich output (tables, images, HTML).
- Implement proper error handling with try-except blocks visible in cells.
- Clear outputs before committing notebooks to version control.
- Use nbconvert for exporting notebooks to scripts or documentation.
- Implement progress bars (tqdm) for long-running operations.
- Use pandas for data manipulation and analysis of NSO data.
- Create reusable utility functions in separate .py files and import them.
- Document assumptions, prerequisites, and expected outcomes in markdown cells.
- Use visualization libraries (matplotlib, plotly) for network topology and metrics visualization.

## Performance Optimization
- Use NSO's commit queue for async service deployment.
- Implement caching for frequently accessed device data.
- Use NSO's reactive FASTMAP for efficient service updates.
- Batch MAAPI operations where possible to reduce transaction overhead.
- Implement connection pooling for LLM API calls.
- Use async operations for parallel device interactions.
- Cache LlamaIndex embeddings and vector stores.
- Implement MCP tool result caching for repeated queries.
- Use asyncio.gather() for parallel MCP tool execution.
- Minimize MCP round-trips by batching related operations in single tools.

## Key Conventions
1. Use NSO's application context and transaction context appropriately.
2. Structure the application:
   - Separate NSO packages from AI automation logic.
   - Use clear separation: MCP tools → service mapping → AI processing → device configuration.
   - Implement modular components for reusability.
   - Use environment variables for LLM API keys, NSO connection details, and MCP server configs.
3. MCP Server Organization:
   - Group related tools by domain (devices, services, alarms, configurations).
   - Use consistent naming conventions for tools (verb_noun pattern: get_device, deploy_service).
   - Implement tool discovery with comprehensive descriptions and examples.
   - Version MCP servers for backward compatibility.

## NSO Service Development
- Follow NSO package structure (src/, templates/, python/, load-dir/).
- Use YANG models for service definition.
- Implement service mapping in Python callbacks.
- Use device templates (XML/CLI) for multi-vendor support.
- Test services with ncs_cli and ncs-netsim.
- Implement proper service lifecycle management (create, modify, delete, re-deploy).

## LlamaIndex Integration Patterns
- **Document Ingestion**: Load YANG models, device configs, network docs into vector stores.
- **Query Engine**: Enable natural language queries about network state and configurations.
- **Agent Workflows**: Implement multi-step automation (analyze → plan → execute → verify).
- **Structured Extraction**: Parse LLM outputs into Pydantic models matching NSO service inputs.
- **RAG (Retrieval Augmented Generation)**: Combine network context with LLM reasoning.

## Data Flow Architecture
```
User Intent (NL) → LlamaIndex Agent → MCP Tools → NSO MAAPI/MAAGIC → 
Service Parameters (Pydantic) → NSO Service Mapping → Device Templates → Network Devices

Alternative Flow:
User Query → MCP Resource → LlamaIndex RAG → Contextualized Response

Hybrid Flow:
User Request → LlamaIndex Planning → MCP Tool Execution → Result Validation → 
LlamaIndex Summary → User Feedback
```

## Authentication and Security
- Use NSO's AAA system for access control.
- Implement secure credential management for device access.
- Protect LLM API keys using environment variables or secrets management.
- Validate and sanitize all inputs before passing to NSO or LLMs.
- Implement audit logging for all automation actions.

## Testing
- Write unit tests using pytest.
- Mock NSO MAAPI/MAAGIC objects for isolated testing.
- Use ncs-netsim for integration testing with simulated devices.
- Test LlamaIndex components with sample data and mock LLM responses.
- Test MCP tools independently using MCP Inspector or custom test clients.
- Implement end-to-end tests for complete automation workflows.
- Use Jupyter notebooks for exploratory testing and prototyping.
- Create test notebooks demonstrating service deployment scenarios.
- Use assert statements in notebooks for inline validation.
- Test MCP + LlamaIndex integration with mock tool responses.
- Validate Pydantic schemas for MCP tool inputs and outputs.

## Monitoring and Observability
- Use NSO's progress trace and commit queues for deployment tracking.
- Implement logging at key points in service mapping and AI processing.
- Track LLM token usage and costs.
- Monitor service deployment success rates and rollback scenarios.
- Use NSO's alarms and notifications for operational awareness.
- Log all MCP tool invocations with input parameters and results.
- Implement metrics collection for MCP tool performance (latency, success rate).
- Use structured logging (JSON) for easier parsing and analysis.
- Track LlamaIndex agent decision paths for debugging.
- Monitor MCP server health and connection status.

## Documentation
- Document YANG models with descriptions and examples.
- Maintain README files for each NSO package.
- Document LlamaIndex prompt templates and agent workflows.
- Document MCP tools with clear descriptions, parameter schemas, and examples.
- Create runbooks for common automation scenarios.
- Keep service mapping logic well-commented.
- Use Jupyter notebooks as living documentation with executable examples.
- Include inline markdown documentation explaining complex logic.
- Create tutorial notebooks for onboarding new team members.
- Export notebooks to HTML/PDF for sharing with non-technical stakeholders.
- Document MCP server endpoints and tool capabilities in OpenAPI/JSON schema format.
- Maintain changelog for MCP tool updates and version history.

## Deployment
- Package NSO services properly (make clean all; ncs_load -l).
- Use NSO's package versioning for controlled rollouts.
- Deploy LlamaIndex components as separate Python services or integrate into NSO.
- Deploy MCP servers as standalone services with proper process management.
- Use Docker/Kubernetes for containerized deployments.
- Implement proper environment separation (dev, staging, production).
- Use CI/CD pipelines for automated testing and deployment.
- Configure MCP server discovery and registration in client applications.
- Implement health checks for MCP servers.
- Use systemd or supervisord for MCP server process management.
- Document MCP server connection strings and authentication requirements.
- Implement graceful shutdown for MCP servers to handle in-flight operations.

## MCP Tool Design Patterns
- **Atomic Tools**: Single-purpose tools for specific NSO operations (get device status, sync-from device).
- **Composite Tools**: Higher-level tools combining multiple operations (deploy and verify service).
- **Query Tools**: Read-only tools for retrieving NSO data (list devices, get service config).
- **Action Tools**: Write operations that modify NSO state (create service, delete device).
- **Streaming Tools**: Tools that provide real-time updates (monitor deployment progress).
- **Batch Tools**: Tools that operate on multiple entities (bulk device sync, mass service deployment).

Refer to Cisco NSO documentation, LlamaIndex documentation, and MCP specification for detailed information on APIs, best practices, and advanced patterns.
